---
title: "Introdução ao R"
author: "Maurício Bueno"
date: "`r Sys.Date()`"
output:
  word_document:
    toc: yes
  html_document:
    toc: yes
    toc_float:
      collapsed: no
editor_options:
  chunk_output_type: console
---

```{r echo=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE)
```

# Introdução

O R é uma linguagem e um ambiente dentro do qual se pode fazer uma infinidade de operações estatísticas e de processamento de dados.
Foi concebido para ser colaborativo e gratuito.
Qualquer pessoa pode criar uma função, ou um conjunto de funções (pacote) e disponibilizar a outros usuários... **gratuitamente**!
Visite o o [site](https://cran.r-project.org/) do R e baixe o programa para instalação em seu computador.

Em associação com o R, costuma-se usar o RStudio (baixe e instale clicando [aqui](https://www.rstudio.com/)), que facilita o uso do R ao disponibilizar um conjunto de quatro janelas que funcionam para as seguintes funções:

1)  a digitação de texto (superior, à esquerda),\
2)  display de resultados (console) (inferior, à esquerda),\
3)  visualizador de objetos (arquivos) gerados ao realizar um trabalho (superior, à direita),
4)  informações gerais: arquivos, plotagens, pacotes instalados, help, e visualizador de imagens (inferior, à direita).

Para a digitação dos comandos, deve-se abrir um novo Script.
Faz-se isso com a seguinte linha de comando: `File + New File + R Script`, ou pressionando simultaneamente os botões `CTRL+SHIFT+N`.
Fazendo isso, abrirá uma aba no quadrante superior esquerdo.
Você pode abrir quantas abas desejar.

É possível rodar um comando no R de duas formas:

-   Selecionando-o e clicando em "Run" na aba superior da área de digitação.

-   Colocar o cursor em qualquer ponto da linha de comando e apertar `CTRL+ENTER`.

Algumas funções não precisam da instalação de pacotes, pois já vêm com o R.
São funções básicas (base), como operações matemáticas, plotagem, estatísticas básicas, entre outras.
Outras funções estão em pacotes que precisam ser **instalados**, por meio do comando `install.packages()`, e **ativados**, por meio do comando `library()`.
Então, vamos instalar alguns pacotes que iremos utilizar durante o curso.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Instalação dos pacotes

if(!require(readxl)) install.packages("readxl",repos = "http://cran.us.r-project.org")

if(!require(tidyverse)) install.packages("tidyverse",repos = "http://cran.us.r-project.org")
if(!require(knitr)) install.packages("knitr",repos = "http://cran.us.r-project.org")
if(!require(kableExtra)) install.packages("kableExtra", repos = "http://cran.us.r-project.org")
if(!require(expss)) install.packages("expss", repos = "http://cran.us.r-project.org")

if(!require(tibble)) install.packages("tibble")
# Ativacao dos pacotes ====

library(readxl)
library(tidyverse)
library(knitr)
library(expss)
```

Todo pacote do R tem uma documentação, com informações sobre as funções que o pacote contém.
Uma forma de encontrar essa documentação é no site [rdocumentation.org](rdocumentation.org).

As funções contidas dentro dos pacotes ser acessadas digitando-se um ponto de interrogação (?) antes do nome da função.
Por exemplo, se quisermos a documentação da função **hist** do pacote base do R, é só rodar o comando:

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
?hist()
```

A documentação aparecerá na aba **Help** do quadrante de visualizações de informações do RStudio.

## Operadores básicos

Existem também alguns operadores importantes no R, que você deve conhecer:\
Um deles é a seta para a esquerda, formada com o sinal de *menor* e o traço de *menos*: `<-`.

Atalho para esse operador: pressione simultaneamente as teclas `ALT` e `-`

Esse operador indica que o resultado de uma operação será salva em um **objeto**.

Por exemplo: o comando abaixo diz "*faça a soma de 3 com 4 e guarde o resultado num objeto chamado **soma**"*.
Esse objeto aparecerá no environment (quadrante superior direito do RStudio).

```{r}
soma <- 3 + 4 
```

O comando "\#" permite que você faça comentários, sem que o R o entenda como comando.
Por exemplo:

```{r}
soma <- 3 + 4   # Esse comando calcula a soma de 3 + 4 e salva no objeto "soma"
```

O texto que aparece após a \#, em outra cor (verde, azul, etc.), é ignorado pelo R.
Esses são os comandos mais básicos.
Há muitos outros atalhos...

```{r echo=FALSE, message=FALSE, warning=FALSE}
atalhos <- data.frame(atalho  =c("CTRL + ENTER",
                                 "CTRL + SHIFT + C",
                                 "CTRL + 1",
                                 "CTRL + 2",
                                 "SETA PARA CIMA (no console)",
                                 "CTRL + ALT + SETA PARA ESQUERDA OU DIREITA",
                                 "CTRL + SHIFT + ENTER",
                                 "CTRL + S",
                                 "CTRL + L",
                                 "ALT + SHIFT + K"),
                      "o que faz"=c("Executa a linha selecionada",
                                    "Comenta e descomenta a linha",
                                    "Passa o cursor para o script",
                                    "Passa o cursor para o console",
                                    "acessa o histórico de comandos anteriores",
                                    "Navega entre as abas de script abertas",
                                    "Executa o Script inteiro",
                                    "Salva o Script",
                                    "Limpa o console",
                                    "Ver a lista de atalhos"
                                    ))
knitr::kable(atalhos, format = "markdown")
```

## Definir diretório de trabalho

Para facilitar o trabalho com salvamento e recuperação de arquivos, é recomendável que se defina um diretório de trabalho, onde todos os arquivos referentes à análise de dados serão salvos.

```{r}
# para verificar o diretório atual, execute o comando: 
getwd()

# OBS.: se for necessário, navegue até o local desejado utilizando a aba "files"

# defina sua pasta de trabalho utilizando a função: 
setwd("C:/Users/jmhbu/OneDrive/Documentos/R/R_basico/Intro_R")
```

## Principais operadores

O R pode ser usado como calculadora...

A tabela a seguir apresenta os principais operadores que usamos nos códigos em R.

```{r echo=FALSE, message=FALSE, warning=FALSE}
table_operadores <- data.frame(Operador = c("+","-","*","/",":","^","sqrt","==",
                                            ">","<","<=",">=","!","&","|"),
                               Descrição = c("Adição",
                                             "Subtração",
                                             "Multiplicação",
                                             "Divisão",
                                             "Sequência",
                                             "Exponencial",
                                             "Raiz",
                                             "Igualdade",
                                             "Maior que",
                                             "Menor que",
                                             "Menor ou igual",
                                             "Maior ou igual",
                                             "Não",
                                             "E",
                                             "Ou"))
knitr::kable(table_operadores, format = "markdown")
```

Exercitando...

```{r echo=TRUE, message=FALSE, warning=FALSE}

# operações matemáticas

3+4
5-2
4*2
9/3
sqrt(9)
2^3

1:10
10:1

#3 = 3
3 == 3
3 > 2
3 < 2
3 >= 2
3 >= 3
3 <= 2:5
3 + 4 >= 14/2

!3 == 5

1 < 2 & 2 < 3

1 == 2 | 2 > 3

```

## Operações lógicas

Algumas palavras são reservadas no R para operações lógicas.
As principais são TRUE, FALSE e NA.

```{r echo=FALSE, eval=TRUE}

op_logicos <- data.frame("Operadores lógicos" = c("NA","NaN","Inf","NULL","TRUE","FALSE"),
                         Significados = c("Not available - dado faltante/indiponível",
                                          "Not a number - indefinições matemáticas como 0/0, log(-1)",
                                          "Infinito - número muito grande, como 1/0 e 10^310",
                                          "Representa ausência de objeto",
                                          "Condição é verdadeira",
                                          "Condição é falsa"))
knitr::kable(op_logicos, format = "markdown")
```

## Criando objetos

Os objetos que podem ser criados no R são:

-   listas

-   vetores

-   matrizes

-   array

-   dataframes

Vamos definir os que mais usamos em nossas análises.

**Lista**: é uma coleção de informações.

```{r}
minha_lista <- list("s01","masculino",23,"ensino médio")
class(minha_lista)

# minha_lista é um objeto do tipo lista, que guarda informações de diferentes tipos: id, sexo, idade, escolaridade
# essas informações foram salvas num objeto do tipo lista, que pode ser visto no environment
# informações não-numéricas aparecem entre "aspas" para o R reconhecer cada elemento dentro do objeto
# as informações dessa lista poderiam ser de um sujeito num df, cada informação é de uma natureza
# o comando "c", significa "concatenar". É usado para inserir mais de uma informação.
```

**Vetor**: é uma coleção de informações ou elementos **da mesma natureza**.
Por exemplo, as variáveis que costumamos colocar nas colunas dos nossos bancos de dados são **vetores**.

```{r}
meu_vetor <- c("masculino","feminino","feminino","masculino","feminino")
is.list(meu_vetor)
is.vector(meu_vetor)
is.data.frame(meu_vetor)

# meu_vetor é um objeto do tipo vetor porque contem informações da mesma natureza. Poderiam ser informações sobre o sexo dos sujeitos em um  banco de dados

vetor1 <- c(1, 5, 3, -10)
vetor2 <- c("a", "b", "c")

class(vetor1)
class(vetor2)

# Se tentarmos misturar duas classes, o R vai apresentar um comportamento conhecido como coerção. Ele vai impor uma das classes aos objetos. Por exemplo:

vetor <- c(1, 2, "a")

vetor
class(vetor)
```

**Dataframe**: é um conjunto de vetores.
Nossos bancos de dados, no R, recebem o nome de dataframes.

```{r}
# criar vetor sexo, em que 1 é masculino e 2 é feminino.
sexo <- c(1,2,1,1,2)
is.vector(sexo)

# pode-se criar um vetor semelhante, mas com letras
# quando uma informação textual for inserida num objeto, ela tem que ir entre aspas.
sexo_cod <- c("m","f","m","m","f") # vetor com informações sobre sexo

idade <- c(25,32,78,12,NA) # vetor com informações de idade

# A partir dos dois vetores anteriores é possível criar um dataframe (conjunto de vetores)
df <- data.frame(sexo_cod,idade)

# acrescentando a variável escolaridade
escolaridade <- c("superior","medio","fundamental","fundamental","medio")

cbind(df,escolaridade) # cbind() é uma função da base que anexa colunas.
df <- cbind(df,escolaridade) 

# acrescentando a variável id
id <- 1:5
df <- cbind(id,df)

# Se quiser inserir um "s" antes do número de cada sujeito, podemos usar a função paste(), que concatena duas partes da informação que constar em uma coluna. Essa função diz: concatene um s com valores de 1 a 5, separados por nada.

paste("s",1:5,sep="")
id <- paste("s",1:5,sep="")

# uma forma de salvar os resultados em uma nova variável diretamente no banco de dados é usando a função $ (cifrão). Quando digitamos o $ em seguida ao nome do objeto (dataframe), o R abre, automaticamente, abre uma janela de opções com as variáveis que existem no dataframe. Ao selecionar "id", por exemplo, os novos dados serão salvos SOBRE os dados existentes. Caso se queira CRIAR uma nova variável, basta digitar o nome de uma variável inexistente no dataframe.

df$id <- paste("s",1:5,sep="")

# se quiser inserir um novo sujeito no dataframe

suj6 <- list(id="s6",sexo_cod="m",idade=34,escolaridade="superior")
suj6 <- list("s6","m",34,"superior")


rbind(df,suj6)
df <- rbind(df,suj6)
glimpse(df)

# inserir a variável renda
# seq(from,to,by,lenth)

df$renda <- seq(1000, by=500,length=6)

# ou
#renda <- seq(1000, by=500,length=6)
#df <- cbind(df,renda)

# inserir uma variável "bonus", referente a um abono de 500 reais a cada sujeito.
# usamos a função rep(), que é semelhante à variável seq(), sem o argumento "by", porque a informação é sempre a mesma
df$bonus <- rep(500,6)
# ou
#bonus <- rep(500,6)
#df <- cbind(df,bonus)

# calcular renda_total, que é a soma das variáveis renda e bonus
df$renda_total <- df$renda + df$bonus

# inserir a variável "Estado Civil"
df$"Estado Civil" <- c("casado/a","solteiro/a","viúvo/a","solteiro/a","casado/a","casado/a")
```

# Funções para visualização de dados

```{r}
df
names(df)
str(df)
glimpse(df)
head(df)
ncol(df)
nrow(df)
view(df)
unique(df$"Estado Civil")
unique(df$idade)
df_copia <- df
df <- df_copia
```

# Funções para manipulação de dados

```{r}
# Alterar o nome da variável "sexo_cod"
df <- rename(df,sexo = sexo_cod)

# Selecionar linhas e colunas: dataframe[linhas,colunas]

df[1:3, ] # seleção das três primeiras linhas
df[ ,1:3] # seleção das três primeiras colunas 
df[1:3,1:3] # seleção das três primeiras linhas e das três primeiras colunas

# Se que quisermos selecionar as linhas 1, 3 e 6, como fazemos?
df[c(1,3,5), ]

# se quisermos selecionar as colunas id, idade e renda_total
df[ ,c(1,3,7)]
df[ ,c("id","idade","renda_total")]
df[ ,c("renda_total","idade","id")]

# Selecionar somente as linhas dos participantes do sexo masculino
df[df$sexo == "m",  ]

# Selecionar somente as linhas dos participantes do sexo masculino com renda_total maior ou igual a 2500 reais.
df[df$sexo == "m" & df$renda_total >= 2500, ]

# Alterar o conteúdo dentro de uma variável

df$sexo[df$sexo == "f"] <- 0
df$sexo[df$sexo == "m"] <- 1

# visualisar que a variável sexo está como character, mas também foi possível perceber que outras variáveis também não estão no formato ideal. Vamos acertar todas elas.
glimpse(df)
str(df)

# mudar variável sexo para factor (note que está como caractere)
df$sexo <- as.numeric(df$sexo)
df$sexo <- as.factor(df$sexo) # factor é uma variável nominal
# df$sexo <- c("m","f","m","m","f","m")

# df$idade <- as.numeric(df$idade)
df$escolaridade <- as.factor(df$escolaridade)

# atribuir levels aos valores 0 e 1 da variável sexo
levels(df$sexo) <- c("feminino","masculino")
levels(df$escolaridade) <- c("fundamental","médio","superior")

# Alterar o nome da variável "Estado Civil"
df <- rename(df,estado_civil = "Estado Civil")

# Alterar a ordem das variáveis no banco de dados
df <- df[ ,c("id","sexo","idade","escolaridade","estado_civil",
             "renda","bonus","renda_total")]

# importar uma planilha do excel
# read_xlsx("Variables.xlsx") # assim, o R importa mas não salva como objeto

variables <- read_xlsx("Variables.xlsx")

df <- cbind(df,read_xlsx("variables.xlsx"))
view(df)

# cbind(df,read_xlsx("Variables.xlsx"))

# Juntar a planilha importada no dataframe df
#df <- cbind(df,variables)

# Exportar dataframes para diversos formatos

# df_copia2 <- df
# df <- df_copia2

saveRDS(df,"df.rds") # formato reconhecido pelo R
write_csv2(df, "df.csv")
writexl::write_xlsx(df,"df.xlsx")

view(df)
# Atribuir labels às variáveis v1 a v5
# vamos supor que essa variávels correspondessem às seguintes perguntas:
# v1 = Você costuma se atrasar para as aulas?
# v2 = Quanto você confia na sua capacidade de aprender?
# v3 = Quão bem você se relaciona com outras pessoas na sua escola?
# v4 = Quanto você gosta de sua escola?
# v5 = Quanto você procrastina para estudar?
# para isso vamos usar a função apply_labels do pacote expss

df  <- apply_labels(df,
       v1 = "Você costuma se atrasar para as aulas?",
       v2 = "Quanto você confia na sua capacidade de aprender?",
       v3 = 'Quão bem você se relaciona com outras pessoas na sua escola?',
       v4 = 'Quanto você gosta de sua escola?',
       v5 = 'Quanto você procrastina para estudar?')

str(df)
glimpse(df)
view(df)
```

# Função `ifelse()`

A função `ifelse()` é bastante útil para a manipulação de dados.
Ela deve ser escrita da seguinte forma: `ifelse("condição", "se sim", "se não")` Traduzindo: observe a condição... se ela ocorrer, faça isso... se ela não ocorrer, faça aquilo.
Exemplos:

```{r}
# se quisermos classificar a renda em dois grupos: menor igual a R$2000 e maior que R$2000, podemos usar a função ifelse()
# ifelse(condição,se sim, se não)
# traduzindo....
# observe se, na variável renda, o valor é menor ou igual a 2000
# se for, então atribua 1
# se não for, então atribua 2.

ifelse(df$renda <= 2000,1,2)

# Se quisermos salvar esses dados como uma coluna do df...
df$renda_cod <- ifelse(df$renda <= 2000,1,2)

# se quisermos criar uma coluna atribuindo 1 para homens e 0 para os demais.
ifelse(df$sexo == "masculino",1,0)

# se quisermos identificar homens com escolaridade fundamental
ifelse(df$sexo == "masculino" & df$escolaridade == "fundamental",1,0)

# se quisermos identificar homens com escolaridade fundamental OU pessoa casadas.
ifelse(df$sexo == "masculino" & df$escolaridade == "fundamental" | df$estado_civil == "casado/a",1,0)

# se quisermos criar uma nova variável atribuindo 1 para solteiro, 2 para casado e 3 para viúvo... tínhamos visto o formato

#df$escolaridade[df$escolaridade == "fundamental"] <- 1
#df$escolaridade[df$escolaridade == "médio"] <- 2
#df$escolaridade[df$escolaridade == "superior"] <- 3

df$escola_cod <- ifelse(df$escolaridade == "fundamental",1,
                        ifelse(df$escolaridade == "médio",2,3))

df$v1 <- ifelse(df$v1 == 1,5,
                ifelse(df$v1 == 2,4,
                       ifelse(df$v1 == 3,3,
                              ifelse(df$v1 == 4,2,1))))

# Também é possível recodificar variáveis de jeito mais fácil, usando uma função do pacote expss.
# Note que há questões no sentido de uma boa adaptação aos estudos e frases no sentido contrário. Nesses casos, não podemos somar os itens diretamente porque um valor 5 em v1 significa má adaptação, enquanto o mesmo valor 5  significa boa adaptação em v2. Então, não podemos somar coisas que têm significados diferentes.
# Para lidar com isso, geralmente, fazemos a inversão de itens que estão na direção contrária do que queremos avaliar. Por exemplo, se queremos avaliar "adaptação escolar", então invertemos os itens v1 e v5, que estão na direção contrária.
# Inverter significa transformar 1 em 5, 2 em 4, 3 em 3, 4 em 2 e 5 em 1. 
# Para isso, usamos a função recode() do expss.

recode(df[ ,c("v1","v2","v3","v4","v5")]) <- c(1~5,2~4,3~3,4~2,5~1)
recode(df[ ,c("v1","v5")]) <- c(1~5,2~4,3~3,4~2,5~1)
```

# Pacote tidyverse

O `tidyverse` é uma família de pacotes que compartilham a mesma filosofia e linguagem de programação.
Fazem parte dessa família pacotes como o `dplyr`, o `readr` e o `ggplot2`, entre outros.
O `dplyr` é um pacote com funções para a **manipulação de dados**, O `ggplot2` é um pacote poderoso para fazer **gráficos** e o `readr` permite a importação e exportação de dados.

Uma função básica do Tidyverse é a **função pipe** `%>%`, que se obtém pressionando as teclas `CTRL+SHIFT+M`.
Essa função pode ser interpretada como "então" e permite escrever códigos na sequência em que ocorrem.
Por exemplo:

```{r}
# para criar e inserir uma variável no banco de dados, ao invés de usar o sistema tradicional, podemos usar a linguagem tidy.

library(tidyverse)

df %>% group_by(sexo) %>% summarise(média = mean(idade))
df %>% group_by(sexo) %>% summarise(média = mean(idade, na.rm = TRUE))
str(df)
```

Na sintaxe acima, usamos algumas funções que serão discutidas a seguir, mas é possível ver como escrevemos os códigos usando o pipe.
Em português, esse código ficaria assim: pegue o dataframe df, **então** agrupe pela variável sexo, **então** calcule as médias de idade.
Esse comando ajuda bastante a escrever códigos mais complexos.

O tidyverse também apresenta diversos recursos para manipulação de dados, entre os quais estão:

```{r echo=FALSE}
tidyverse_table <- data.frame("Funções tidyverse(dplyer)"=c(
                              "select()",
                              "filter()",
                              "slice()",
                              "arrange()",
                              "mutate()",
                              "group_by()"),
                              "O que faz"=c("seleciona colunas do dataframe",
                                            "filtra linhas por categoria de variável",
                                            "filtra linhas inteiras do dataframe",
                                            "reordena as linhas do dataframe",
                                            "cria novas colunas no dataframe",
                                            "realiza os comandos que vierem a seguir pelas variáveis selecionadas"))
library(knitr)

tidyverse_table %>% kable(format = "markdown")
```

Vamos testar uma por uma, com o nosso dataframe df, começando pela função `select()`, que seleciona **colunas** do dataframe.

## select()

```{r}
# SELECT

names(df) # visualisar número das colunas
df %>% names() %>% as.data.frame()
# pegar df e selecionar as colunas 1,2,4,5 e de 9 a 13

df[ ,c("id","sexo","escolaridade","estado_civil","v1","v2","v3","v4","v5")]

df %>% select(1,2,4,5,9:13) # o comando pipe diz o que é pra fazer com o dataframe 
df %>% select(id, sexo, v1,v2,v3,v4,v5)

# podemos salvar esse novo dataframe com um novo nome. Ao rodar o código abaixo, será criado um objeto df1 no Global Environment

df1 <- df %>% select(1,2,4,5,9:13)

# usar select para deletar uma coluna 

df1 %>% select(-4) # deletar a coluna estado_civil

# usar select para reordenar as colunas

df1 %>% select(5:9,1,3,2,4)

# vamos aproveitar e deletar as duas últimas colunas do df

names(df)     # ver o nome e o número das colunas, para identificar que as duas últimas                  colunas são a 14 e a 15.

df %>% select(-14,-15)
df %>% select(-c(14,15))
df %>% select(-c(renda_cod,escola_cod))

df <- df %>% select(-c(renda_cod,escola_cod))

# reorganização do banco de dados

df %>% select(sexo,everything())
```

## filter()

Se a função `select()` permite a seleção de colunas de um dataframe, a função `filter()` permite a seleção de **linhas**.

```{r}
## se quisermos filtrar somente os participantes do sexo masculino

df %>% filter(sexo == "masculino")

## pode-se acrescentar outras variáveis para filtrar
## por exemplo, filtrar participantes do sexo masculino, com nivel fundamental de escolaridade

df %>% filter(sexo == "masculino",escolaridade == "fundamental")

## ou ainda participantes do sexo masculino, do esnisno fundamental e solteiro/a
df %>% filter(sexo == "masculino",escolaridade == "fundamental",estado_civil == "solteiro/a")

## se quisermos retirar do banco todos os participantes com ensino fundamental.
## observe que o ponto de exclamação no código é uma espécie de "tudo, menos..."
df %>% filter(!escolaridade == "fundamental")
df %>% filter(!escolaridade == "fundamental",renda>=3000)

## ou, se quiser selecionar participantes com renda_total superior ou igual a R$ 2000,00.
df %>% filter(renda_total >= 2000)

## OBS.: lembrando que se quisermos salvar a filtragem em um novo dataframe...
df_renda_maior2000 <- df %>% filter(renda_total >= 2000)
```

As funções `select()` e `filter()` são muito úteis para limpeza do banco de dados.
Por exemplo, quando baixamos um banco de dados do google formulário, ele vem com as informações de data e hora que o participante respondeu o questionário, com as respoostas ao TCLE, que normalmente não iremos utilizar nas análises.
Então, podemos deletá-las usando a função `select()`.
Outra aplicação muito comum é para criar um *subset* do arquivo base, que contenha somente os itens de um dos instrumentos, para análise de suas propriedades psicométrias.\
De forma semelhante, podemos usar a função `filter()` para eliminar sujeitos que não atendem aos critérios de inclusão da pesquisa.
Ou selecionar um *subset* do banco de dados, que contenha os sujeitos de interesse.

## slice()

Uma opção para selecionar casos com base na linha inteira é a função slice().

```{r}
# selecionar linhas inteiras
df %>% slice(1:3)
df %>% slice(1,4,6)

# selecionar por exclusão
df %>% slice(-1)
df %>% slice(-c(1,6))
df %>% slice(-1,-6)

# sortear uma proporção do banco de dados
df %>% slice_sample(prop = .35)
df %>% slice_sample(n=3)
```

## arrange()

Por sua vez, a função `arrange()`, ordena os dados por um critério.

```{r}
# Ordenar df por idade
df %>% arrange(idade)

# Ordenar df por ordem decrescente de renda_total
df %>% arrange(desc(renda_total))

# É possível inserir mais de uma variável, por exemplo, sexo e renda_total
df %>% arrange(sexo,desc(renda_total))
```

A função `mutate()` permite criar variáveis dentro de um dataframe.
É muito útil para calcular pontuações a partir de itens, por exemplo, ou para fazer transformações de outras variáveis.\
\#\# mutate

```{r}
# calcular as pontuações das pessoas nos itens de v1 a v5.
df %>% mutate(escore = v1+v2+v3+v4+v5)
df %>% mutate(escore = (v1+v2+v3+v4+v5)/5)
# se quisermos salvar a nova variável, então o código seria...
df <- df %>% mutate(escore = v1+v2+v3+v4+v5)
```

## group_by

A função `group_by` agrupa os resultados de uma operação e, geralmente, é usada juntamente com alguma outra operação, como por exemplo, a função `summarise()`.

```{r}

# calcular as médias da variável escore, por sexo (grupo_by(sexo))
df %>% group_by(sexo) %>% count(escolaridade)
df %>% group_by(sexo) %>% summarise(mean(escore))
df %>% group_by(sexo,escolaridade) %>% summarise(mean(escore))
```

## pivot_longer e pivot_wider (funções tidyr)

Às vezes precisamos fazer transformações no formato do banco de dados para fazer alguma análise estatística ou gráfico.
Precisamos transformar as linhas em colunas ou as colunas em linhas.
Esses dois comandos do dplyr ajudam a realizar esses procedimentos.

```{r}
# ACRESCENTAR INFORMAÇÃO
```

## Exercícios

```{r}
dim(df) # ver número de linhas e colunas do dataframe df
imdb <- readr::read_rds("imdb.rds")
str(imdb)

# crie uma variável id para todos os sujeitos do dataframe

# selecione as variáveis título, duração, cor e gênero dos 1000 primeiros casos do banco de dados

# monte um dataframe somente com os filmes do diretor Clint Eastwood

# reorganize o banco de dados com filmes do diretor Clint Eastwood por ordem decrescente de receita

# selecione uma amostra aleatória do dataframe imdb com 45% dos filmes relacionados.

# crie uma tabela com as médias de orçamento e de receita, por diretor.

```

# Funções estatísticas básicas

É possível falzer algumas operações matemáticas e de estatística descritiva, com as funções básicas do R.
Algumas vezes temos que calcular pontuações a partir da somatória ou da média dos valores atribuídos pelos respondentes aos itens.

## rowSums() e rowMeans()

```{r}
## calcular pontuações das pessoas em um conjunto de itens.
## vamos supor que v1, v2 e v5 formam a pontuação em um fator
## e que v3 e v4 formam a pontuação em outro fator

## se quisermos calcular a somatória das pontuações nesses dois fatores, podemos usar:
df %>% select(v1,v2,v5) %>% rowSums()
## para salvar esses resultados em uma nova coluna no dataframe df, basta usar df$nome
df$sum1 <- df %>% select(v1,v2,v5) %>% rowSums()
df$sum2 <- df %>% select(v3,v4) %>% rowSums()

## podemos calcular essas pontuações pela média nos itens ao invés da somatória
df$mean1 <- df %>% select(v1,v2,v5) %>% rowMeans() %>% round(digits = 1)
df$mean2 <- df %>% select(v3,v4) %>% rowMeans()
```

## count()

```{r}
# contar casos dentro de uma variável. 
# Função útil, por exemplo, para descrever a amostra.
# dependendo de como se escreve essa função ela dá um tipo de informação.

count(df) # se colocar apenas o nome do dataframe, retorna o número de casos total
count(df,sexo) # especificando uma varíável, retorna o número de casos dentro da variável
count(df,sexo,escolaridade) # comando igual a df %>% group_by(sexo) %>% count(escolaridade)

# para acrescentar uma coluna com as respectivas porcentagens
df %>% count(sexo) %>% mutate(porc = n/sum(n)*100)
df %>% count(sexo,escolaridade) %>% mutate(porc = n/sum(n)*100)
```

## Estatísticas de tendência central e de disperção

A função `rowMeans()` calcula a média de algumas variáveis em uma **linha**.\
Se quisermos calcular a média e o desvio padrão dos valores de uma **coluna** (variável), temos que usar as funções `mean()` e `sd()`.\
Outras medidas de tendência central são a mediana e a moda
.

```{r}
# média das pontuações as variáveis "idade", "renda_total", "escore".
mean(df$idade)

# ao rodar essa análise, notei que a variável "idade" está como character
# ou seja, os valores numéricos estão sendo entendidos como texto
# então, precisamos fazer uma transformação dessa variável em numérica.

df$idade <- as.numeric(as.character(df$idade))

# agora, rodar novamente a média
mean(df$idade, na.rm = TRUE) # na coluna idade, há um valor de idade não informado (NA)
                             # o comando precisa informar que os NAs devem ser removidos
                             # por isso o comando "na.rm = TRUE"

# procedimento semelhante para o cálculo do desvio padrão.
sd(df$idade, na.rm = TRUE)

# mediana
median(df$idade,na.rm = TRUE)

# moda
count(df,escore)
```

# Gráficos

O pacote ggplot2 é um dos que integram a família tidyverse.
Ele foi estruturado segundo a Gramática dos Gráficos, em que os comandos são dados por camadas.
As três principais camadas são **dados**, **estética** e **geom**.
Para realizar as próximas análises iremos utilizar o banco de dados `big_five.rds`, que terá que ser importado para o R.
Esse banco contém as respostas de 19.719 participantes que responderam a 50 itens relacionados aos cinco grandes fatores de personalidade (extroversão, neuroticismo, cosncienciosidade, amabilidade e abertura).
Se você tem um email institucional da UFPE, [clique aqui para baixar o arquivo](https://drive.google.com/file/d/1JEGTkN3T66ubSSVROPVuao9oF9XAzII3/view?usp=sharing).
**Salve-o na mesma pasta do R que estão os arquivos utilizados neste disciplina**.
Se não tem o email institucional, o arquvio está disponível em formato `.csv` [nesta página](https://openpsychometrics.org/_rawdata/).

## Preparação do banco de dados

Para importar o arquivo `big_five.rds` para dentro do R usamos a função `read_rds()` do pacote `readr`.
Para não ter que instalar e carregar esse pacote vamos chamar a função de dentro do pacote usando o script abaixo.

```{r}
# importar o arquivo big_five.rds para dentro do R

big_five <- readr::read_rds("big_five.rds")


# Seleção de uma pequena parte (20 sujeitos) do banco de dados big_five, para ficar visualmente mais interessante.

big_five20 <- big_five %>% slice(1:20)
```

## Gráficos de pontos

Num gráfico de pontos, cada ponto representa a interseção entre as variáveis x e y de cada caso.
No exemplo a seguir, o gráfico de pontos representa as intersecções entre as variáveis extroversão e amabilidade.
Cada ponto representa uma pessoa.
De cada ponto é possível projetar perpendiculares aos eixos x e y, correspondentes às pontuações dessa pessoa nas variáveis extroversão e amabilidade, respectivamente.

Então, a tradução do script abaixo ficaria assim: use o pacote ggplot2 (`ggplot`) e o dataframe big_five20 (`data = big_five20`) para criar um gráfico de pontos (`geom_point`), em que os eixos x e y são representados pelos valores dispostos nas variáveis extroversão e amabilidade (`aes(x = extr, y = amab)`), respectivamente.

```{r}
ggplot(data = big_five20) +
    geom_point(aes(x = extr, y = amab))
```

Obs: para uma melhor visualização do gráfico, neste caso, usamos o dataframe `big_five20`, que contém apenas os 20 primeiros casos do dataframe `big_five`.

## Histograma

Um histograma representa a distribuição dos valores em uma variável.
No eixo x estão os valores que aparecem na variável sob consideração (no caso, fizemos uma gráfico para cada um dos cinco grandes fatores de personalidade); no eixo y está a frequência com que cada valor de x aparece na amostra.
Como o eixo y é sempre a frequencia, no caso do histograma `(geom_histogram`), precisamos definir apenas a variável que entrará no eixo x.

```{r}

ggplot(data = big_five, aes(x = extr)) +
  geom_histogram()
```

No histograma da variável extroversão, acima, observa-se que há poucos escores baixos (próximos de 1 no eixo x) e altos (próximos de 5 no eixo x) e muitas pessoas com escores ao redor de 3.
Note que a distribuição se aproxima de uma distribuição normal.
Pode-se aplicar scripts semelhantes para a obtenção de histogramas dos outros quatro fatores.

```{r}
ggplot(data = big_five, aes(x = neur)) +
  geom_histogram()

ggplot(data = big_five, aes(x = amab)) +
  geom_histogram()

ggplot(data = big_five, aes(x = cons)) +
  geom_histogram()

ggplot(data = big_five, aes(x = aber)) +
  geom_histogram()
```

## Gráfico de barras

O gráfico de barras (`geom_bar`) é um gráfico com barras retangulares e comprimento proporcional aos valores que ele apresenta.
Nos exemplos abaixo, as barras representam a quantidade de pessoas (`..count..`) por gênero (primeiro gráfico) ou por raça (segundo gráfico)

```{r}
ggplot(data = big_five, aes(x = gênero, y = ..count..)) +
  geom_bar()

ggplot(data = big_five, aes(x = raça, y = ..count..)) +
  geom_bar()
```

## Boxplot

O boxplot, também chamado de diagrama de caixa é um gráfico que representa a variação de dados por meio de quartis.
A haste inferior à caixa representa o primeiro quartil; a caixa representa os quartis 2 e 3, que estão separados pelo traço central correspondente à mediana; e a haste superior à caixa, representa a distribuição dos valores no quarto quartil.
Assim, é preciso definir as variáveis que vão em x e y, sendo que y sempre deve ser uma variável contínua.

```{r}
ggplot(data = big_five, aes(x = gênero, y = extr)) +
  geom_boxplot()

ggplot(data = big_five, aes(x = gênero, y = cons)) +
  geom_boxplot()

ggplot(data = big_five, aes(x = gênero, y = neur)) +
  geom_boxplot()

ggplot(data = big_five, aes(x = gênero, y = amab)) +
  geom_boxplot()

ggplot(data = big_five, aes(x = gênero, y = aber)) +
  geom_boxplot()
```

## Gráfico de linhas

Se assemelha a um gráfico de pontos, em que os pontos não estão exatamente dispersos em um plano, mas organizados em uma sequência, o que permite que eles sejam ligados por um segmento de reta, facilitando a visualização das variações entre os pontos.
No exemplo abaixo, a linha liga a quantidade de pessoas por gênero.

```{r}

ggplot(data = big_five) +
  geom_line(aes(x = gênero, group = 1), stat = "count")
  
```

## Modificação de argumentos dentro do geom (color, shape, size)

Uma coisa importante nos gráficos é que eles sejam visualmente atrativos.
Para isso, podemos alterar diversos argumentos que os compõem, como cores, formas (shapes) e tamanhos (sizes).

```{r}
ggplot(data = big_five20) +
  geom_point(aes(x = extr, y = amab, color = gênero))


ggplot(data = big_five20) +
  geom_point(aes(x = extr, y = amab, shape = gênero))

# retirando color de dentro de aes
ggplot(data = big_five20) +
  geom_point(aes(x = extr, y = amab, shape = gênero),
             color = "darkolivegreen")
```

As cores podem ser inseridas pelo seu nome ou pelo seu código.
[Clique aqui](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf "Paleta de cores") para baixar um arquivo com os nomes das cores do R... e [aqui](https://coolors.co/ "Site gerador de paletas") para acessar um site gerador de paletas de cores, por código.
Os códigos devem ser inseridos após uma hashtag.

```{r}
ggplot(data = big_five20) +
  geom_point(aes(x = extr, y = amab, shape = gênero),
             color = "#3d5a80")
# Site gerador de paletas: https://coolors.co/

```

Também é possível modificar o formato (shape) dos pontos.
[Este site](http://www.sthda.com/english/wiki/ggplot2-point-shapes) tem uma lista dos shapes que podem ser utilizados.

```{r}
ggplot(data = big_five20) +
  geom_point(aes(x = extr, y = amab),
             color = "#61988E", shape = 18)
# Shapes possíveis: http://www.sthda.com/english/wiki/ggplot2-point-shapes

ggplot(data = big_five20) +
  geom_point(aes(x = extr, y = amab),
             color = "#61988E", shape = 18, size = 5)
# é possível ajustar a borda (color) e o preenchimento dos pontos (fill)
# nesse site, os shapes de 21 a 25 permitem ajuste de color e fill
ggplot(data = big_five20) +
  geom_point(aes(x = extr, y = amab),
             fill = "#61988E", color = "black", shape = 25, size = 8)
```

## Adicionando um segundo geom

Como foi dito anteriormente, o ggplot segue o principio de camadas sobrepostas.
Portanto, é possível adicionar várias camadas, como outro geom, por exemplo.

```{r}
#ggplot(data = big_five20) +
#  geom_point(aes(x = extr, y = amab),
#             color = "#61988E", shape = 16, size = 2) +
#  geom_line(aes(x = extr, y = amab), stat = "smooth", 
#            method = "lm")

ggplot(data = big_five20, aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 2) +
  geom_line()

ggplot(data = big_five20, aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 2) +
  geom_line(stat = "smooth", method = "lm")

```

```{r}

# alterando o tipo de curva de interpolação dos pontos

ggplot(data = big_five20, aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 2) +
  geom_smooth()


ggplot(data = big_five20, aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 2) +
  geom_smooth(method = "lm", se = FALSE, color = "black", size = 1)

# Mudando o tipo de linha
ggplot(data = big_five20, aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 2) +
  geom_smooth(method = "lm", se = F, color = "black", size = 0.7,
              linetype = "dashed")

## Especificando aes específicas para um dos geoms
ggplot(data = big_five20, aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 0.7) +
  geom_smooth(method = "lm", se = F, color = "black", size = 0.5,
              aes(linetype = gênero))

## Especificando aes específicas para um dos geoms
ggplot(data = big_five20, aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 0.7) +
  geom_smooth(method = "lm", se = F, size = 0.5,
              aes(color = gênero))

```

## dplyr e ggplot

Uma opção interessante para a elaboração de gráficos é combinar funções do dplyr com as do ggplot.
Por exemplo, ao invés de criar um dataframe com 20 sujeitos, como estávamos fazendo até aqui, podemos selecionar a quantidade de sujeitos desejada por meio da função slice.

```{r}
# repetindo o último gráfico, mas combinando dplyr com ggplot
big_five %>% slice(1:20) %>% 
ggplot(aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 0.7) +
  geom_smooth(method = "lm", se = F, size = 0.5,
              aes(color = gênero))

# ou, se quisermos fazer o mesmo gráfico com 1% da amostra
big_five %>% slice_sample(prop = .01) %>% 
  ggplot(aes(x = extr, y = amab)) +
  geom_point(color = "#61988E", shape = 16, size = 2) +
  geom_smooth(method = "lm", se = F, size = 1,na.rm = TRUE,
              aes(color = gênero))
```

## Usando funções estatísticas

```{r}
## Usando o geom para representar um "summary"
### (stat = summary) x stat_summary()

big_five %>% filter(idade <= 80) %>% # tem idades erradas no banco
ggplot() +
  geom_point(aes(x = gênero, y = idade), stat = "summary", fun = "mean")

# mesmo gráfico que o anterior, mas usando a função stat_summary
big_five %>% filter(idade <= 80) %>%
ggplot(aes(x = gênero, y = idade)) +
  stat_summary(geom = "point", fun = "mean")

# usando a mediana no lugar da média.
big_five %>% filter(idade <= 80) %>%
ggplot(aes(x = gênero, y = idade)) +
  stat_summary(geom = "point", fun = "median")

## Incluindo barras de erros (usando também o summary)

big_five %>% filter(idade <= 80) %>%
ggplot(aes(x = gênero, y = idade)) +
  geom_point(stat = "summary", fun = "mean") +
  geom_errorbar(stat = "summary", fun.data = "mean_se")

# usando width para melhorar a visualiazação

big_five %>% filter(idade <= 80) %>%
ggplot(aes(x = gênero, y = idade)) +
  geom_point(stat = "summary", fun = "mean") +
  geom_errorbar(stat = "summary", fun.data = "mean_se", width = 0.3)

# trocando erro da média (mean_se) pelo mínimo e máximo.

big_five %>% filter(idade <= 80) %>%
ggplot(aes(x = gênero, y = idade)) +
  geom_point(stat = "summary", fun = "mean") +
  geom_errorbar(stat = "summary", fun.min = "min", fun.max = "max")
```
